local ls = require("luasnip")
-- some shorthands...
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local l = require("luasnip.extras").lambda
local rep = require("luasnip.extras").rep
local p = require("luasnip.extras").partial
local m = require("luasnip.extras").match
local n = require("luasnip.extras").nonempty
local dl = require("luasnip.extras").dynamic_lambda
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local types = require("luasnip.util.types")
local conds = require("luasnip.extras.conditions.expand")

return {
	s(
		{ trig = "pypy_recursion", dscr = "pypyで再帰関数を使うときのおまじない" },
		t({
			"import pypyjit",
			"pypyjit.set_param('max_unroll_recursion=-1')",
		})
	),
	s(
		{ trig = "meguru", dscr = "めぐる式二分探索" },
		t({
			"def func(x: int) -> bool:",
			"    pass",
			"",
			"",
			"left = -1",
			"right = N + 1",
			"while right - left > 1:",
			"    mid = left + (right - left) // 2",
			"    if func(mid):",
			"        left = mid",
			"    else:",
			"        right = mid",
			"ans = left",
		})
	),
	s(
		{ trig = "divisors", dscr = "nの約数を列挙しlistで返却する" },
		t({
			"def get_divisors(n):",
			"    lower, upper = [], []",
			"    i = 1",
			"    while i * i <= n:",
			"        if n % i == 0:",
			"            lower.append(i)",
			"            if i != n // i:",
			"                upper.append(n // i)",
			"        i += 1",
			"    return lower + upper[::-1]",
		})
	),
	s(
		{ trig = "primes", dscr = "nまでの素数をlistで返却する" },
		t({
			"def get_prime(n):",
			"    table = [i for i in range(0, n + 1)]",
			"    prime = [True for _ in range(0, n + 1)]",
			"    prime[0] = False",
			"    prime[1] = False",
			"    for d in table:",
			"        if not prime[d]:",
			"            continue",
			"        for nd in range(d * d, n + 1, d):",
			"            prime[nd] = False",
			"        ret = []",
			"        for d in table:",
			"            if not prime[d]:",
			"                continue",
			"            ret.append(d)",
			"        return ret",
		})
	),
	s(
		{ trig = "factorization", dscr = "素因数分解 [[素因数,指数],...]で返却" },
		t({
			"def factorization(n):",
			" 	ret = []",
			"	if n == 1:",
			"		return ret",
			"	temp = n",
			"	prime = get_prime(int(n**0.5) + 1)",
			"	for i in prime:",
			"		if temp % i == 0:",
			"			cnt = 0",
			"			while temp % i == 0:",
			"				cnt += 1",
			"				temp //= i",
			"			ret.append([i,cnt])",
			"	if temp != 1:",
			"		ret.append([temp, 1])",
			"	if ret == []:",
			"		ret.append([n, 1])",
			"	return ret",
		})
	),
	s(
		{ trig = "unionfind", dscr = "Union-Find" },
		t({
			"from collections import defaultdict",
			"",
			"",
			"class UnionFind():",
			"    def __init__(self, n):",
			"        self.n = n",
			"        self.parents = [-1] * n",
			"",
			"    def find(self, x):",
			"        if self.parents[x] < 0:",
			"            return x",
			"        else:",
			"            self.parents[x] = self.find(self.parents[x])",
			"            return self.parents[x]",
			"",
			"    def union(self, x, y):",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"        if x == y:",
			"            return",
			"        if self.parents[x] > self.parents[y]:",
			"            x, y = y, x",
			"        self.parents[x] += self.parents[y]",
			"        self.parents[y] = x",
			"",
			"    def size(self, x):",
			"        return -self.parents[self.find(x)]",
			"",
			"    def same(self, x, y):",
			"        return self.find(x) == self.find(y)",
			"",
			"    def members(self, x):",
			"        root = self.find(x)",
			"        return [i for i in range(self.n) if self.find(i) == root]",
			"",
			"    def roots(self):",
			"        return [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"    def group_count(self):",
			"        return len(self.roots())",
			"",
			"    def all_group_members(self):",
			"        group_members = defaultdict(list)",
			"        for member in range(self.n):",
			"            group_members[self.find(member)].append(member)",
			"        return group_members",
			"",
			"    def __str__(self):",
			"        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())",
		})
	),
	s(
		{ trig = "unionfind", dscr = "Union-Find (dict)" },
		t({
			"import collections",
			"class UnionFind():",
			"    def __init__(self):",
			"        '''",
			"        unionfind経路圧縮あり,要素にtupleや文字列可,始めに要素数指定なし",
			"        '''",
			"        self.parents = dict()                                      # {子要素:親ID,}",
			"        self.members_set = collections.defaultdict(lambda : set()) # keyが根でvalueが根に属する要素要素(tupleや文字列可)",
			"        self.roots_set = set()                                     # 根の集合(tupleや文字列可)",
			"        self.key_ID = dict()                                       # 各要素にIDを割り振る",
			"        self.ID_key = dict()                                       # IDから要素名を復元する",
			"        self.cnt = 0                                               # IDのカウンター",
			"",
			"    def dictf(self,x): # 要素名とIDをやり取りするところ",
			"        if x in self.key_ID:",
			"            return self.key_ID[x]",
			"        else:",
			"            self.cnt += 1",
			"            self.key_ID[x] = self.cnt",
			"            self.parents[x] = self.cnt",
			"            self.ID_key[self.cnt] = x",
			"            self.members_set[x].add(x)",
			"            self.roots_set.add(x)",
			"            return self.key_ID[x]",
			"",
			"    def find(self, x):",
			"        ID_x = self.dictf(x)",
			"        if self.parents[x] == ID_x:",
			"            return x",
			"        else:",
			"            self.parents[x] = self.key_ID[self.find(self.ID_key[self.parents[x]])]",
			"            return self.ID_key[self.parents[x]]",
			"",
			"    def union(self, x, y):",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"        if self.parents[x] > self.parents[y]:",
			"            x, y = y, x",
			"        if x == y:",
			"            return",
			"        for i in self.members_set[y]:",
			"            self.members_set[x].add(i)",
			"        self.members_set[y] = set()",
			"        self.roots_set.remove(y)",
			"        self.parents[y] = self.key_ID[x]",
			"",
			"    def size(self, x):#xが含まれる集合の要素数",
			"        return len(self.members_set[self.find(x)])",
			"",
			"    def same(self, x, y):#同じ集合に属するかの判定",
			"        return self.find(x) == self.find(y)",
			"",
			"    def members(self, x):#xを含む集合の要素",
			"        return self.members_set[self.find(x)]",
			"",
			"    def roots(self):#根の要素",
			"        return self.roots_set",
			"",
			"    def group_count(self):#根の数",
			"        return len(self.roots_set)",
			"",
			"    def all_group_members(self):#根とその要素",
			"        return {r: self.members_set[r] for r in self.roots_set}",
		})
	),
	s(
		{ trig = "sortedset", dscr = "SortedSet" },
		t({
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			'T = TypeVar("T")',
			"",
			"class SortedSet(Generic[T]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			'        "Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)"',
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        if any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"            a, b = [], a",
			"            for x in b:",
			"                if not a or a[-1] != x:",
			"                    a.append(x)",
			"        bucket_size = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // bucket_size : n * (i + 1) // bucket_size] for i in range(bucket_size)]",
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"",
			"    def __len__(self) -> int:",
			"        return self.size",
			"",
			"    def __repr__(self) -> str:",
			'        return "SortedSet" + str(self.a)',
			"",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			'        return "{" + s[1 : len(s) - 1] + "}"',
			"",
			"    def _position(self, x: T) -> Tuple[List[T], int, int]:",
			'        "return the bucket, index of the bucket and position in which x should be. self must not be empty."',
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def add(self, x: T) -> bool:",
			'        "Add an element and return True if added. / O(√N)"',
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return True",
			"        a, b, i = self._position(x)",
			"        if i != len(a) and a[i] == x: return False",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"        return True",
			"",
			"    def _pop(self, a: List[T], b: int, i: int) -> T:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: T) -> bool:",
			'        "Remove an element and return True if removed. / O(√N)"',
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"",
			"    def lt(self, x: T) -> Optional[T]:",
			'        "Find the largest element < x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Optional[T]:",
			'        "Find the largest element <= x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Optional[T]:",
			'        "Find the smallest element > x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Optional[T]:",
			'        "Find the smallest element >= x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, i: int) -> T:",
			"        'Return the i-th element.'",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def pop(self, i: int = -1) -> T:",
			"        'Pop and return the i-th element.'",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			"        'Count the number of elements < x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			"        'Count the number of elements <= x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans",
		})
	),
	s(
		{ trig = "SortedMultiSet", dscr = "SortedMultiSet" },
		t({
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedMultiset(Generic[T]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			'        "Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)"',
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        bucket_size = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // bucket_size : n * (i + 1) // bucket_size] for i in range(bucket_size)]",
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"",
			"    def __len__(self) -> int:",
			"        return self.size",
			"",
			"    def __repr__(self) -> str:",
			'        return "SortedMultiset" + str(self.a)',
			"",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			'        return "{" + s[1 : len(s) - 1] + "}"',
			"",
			"    def _position(self, x: T) -> Tuple[List[T], int, int]:",
			'        "return the bucket, index of the bucket and position in which x should be. self must not be empty."',
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def count(self, x: T) -> int:",
			'        "Count the number of x."',
			"        return self.index_right(x) - self.index(x)",
			"",
			"    def add(self, x: T) -> None:",
			'        "Add an element. / O(√N)"',
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return",
			"        a, b, i = self._position(x)",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"",
			"    def _pop(self, a: List[T], b: int, i: int) -> T:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: T) -> bool:",
			'        "Remove an element and return True if removed. / O(√N)"',
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"",
			"    def lt(self, x: T) -> Optional[T]:",
			'        "Find the largest element < x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Optional[T]:",
			'        "Find the largest element <= x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Optional[T]:",
			'        "Find the smallest element > x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Optional[T]:",
			'        "Find the smallest element >= x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, i: int) -> T:",
			'        "Return the i-th element."',
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def pop(self, i: int = -1) -> T:",
			'        "Pop and return the i-th element."',
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			'        "Count the number of elements < x."',
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			'        "Count the number of elements <= x."',
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans",
		})
	),
}
