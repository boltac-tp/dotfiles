local ls = require("luasnip")
-- some shorthands...
local s = ls.snippet
local sn = ls.snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local l = require("luasnip.extras").lambda
local rep = require("luasnip.extras").rep
local p = require("luasnip.extras").partial
local m = require("luasnip.extras").match
local n = require("luasnip.extras").nonempty
local dl = require("luasnip.extras").dynamic_lambda
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local types = require("luasnip.util.types")
local conds = require("luasnip.extras.conditions.expand")

return {
	s(
		{ trig = "meguru", dscr = "めぐる式二分探索" },
		t({
			"def func(x:int) -> bool:",
			"    pass",
			"",
			"",
			"left = -1",
			"right = N + 1",
			"while right - left >1:",
			"    mid = left + (right - left) // 2",
			"    if func(mid):",
			"        left = mid",
			"    else:",
			"        right = mid",
			"ans = left",
		})
	),
	s(
		{ trig = "divisors", dscr = "nの約数を列挙しlistで返却する" },
		t({
			"def get_divisors(n):",
			"    lower, upper = [], []",
			"    i = 1",
			"    while i * i <= n:",
			"        if n % i == 0:",
			"            upper.append(n // i)",
			"        i += 1",
			"    return lower+upper[::-1]",
		})
	),
	s(
		{ trig = "primes", dscr = "nまでの素数をlistで返却する" },
		t({
			"def get_prime(n):",
			"    table = [i for i in range(0, n + 1)]",
			"    prime = [True for _ in range(0, n + 1)]",
			"    prime[0] = False",
			"    prime[1] = False",
			"    for d in table:",
			"        if not prime[d]:",
			"            continue",
			"        for nd in range(d * d, n + 1, d):",
			"            prime[nd] = False",
			"        ret = []",
			"        for d in table:",
			"            if not prime[d]:",
			"                continue",
			"            ret.append(d)",
			"        return ret",
		})
	),
	s(
		{ trig = "factorization", dscr = "素因数分解 [[素因数,指数],...]で返却" },
		t({
			"def factorization(n):",
			" 	ret = []",
			"	if n==1:",
			"		return ret",
			"	temp = n",
			"	prime = get_prime(int(n**0.5)+1)",
			"	for i in prime:",
			"		if temp % i == 0:",
			"			cnt = 0",
			"			while temp % i == 0:",
			"				cnt += 1",
			"				temp //= i",
			"			ret.append([i,cnt])",
			"	if temp != 1:",
			"		ret.append([temp, 1])",
			"	if ret == []:",
			"		ret.append([n, 1])",
			"	return ret",
		})
	),
	s(
		{ trig = "unionfind", dscr = "Union - Find" },
		t({
			"from collections import defaultdict",
			"",
			"",
			"class UnionFind():",
			"    def __init__(self, n):",
			"        self.n = n",
			"        self.parents = [-1] * n",
			"",
			"    def find(self, x):",
			"        if self.parents[x] < 0:",
			"            return x",
			"        else:",
			"            self.parents[x] = self.find(self.parents[x])",
			"            return self.parents[x]",
			"",
			"    def union(self, x, y):",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"        if x == y:",
			"            return",
			"        if self.parents[x] > self.parents[y]:",
			"            x, y = y, x",
			"        self.parents[x] += self.parents[y]",
			"        self.parents[y] = x",
			"",
			"    def size(self, x):",
			"        return -self.parents[self.find(x)]",
			"",
			"    def same(self, x, y):",
			"        return self.find(x) == self.find(y)",
			"",
			"    def members(self, x):",
			"        root = self.find(x)",
			"        return [i for i in range(self.n) if self.find(i) == root]",
			"",
			"    def roots(self):",
			"        return [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"    def group_count(self):",
			"        return len(self.roots())",
			"",
			"    def all_group_members(self):",
			"        group_members = defaultdict(list)",
			"        for member in range(self.n):",
			"            group_members[self.find(member)].append(member)",
			"        return group_members",
			"",
			"    def __str__(self):",
			"        return '\\n'.join(f'{r}: {m}' for r, m in self.all_group_members().items())",
		})
	),
	s(
		{ trig = "SortedSet", dscr = "SortedSet" },
		t({
			"# https://github.com/tatyam-prime/sortedset/blob/main/sortedset.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import generic, iterable, iterator, typevar, union, list",
			"T = typevar('t')",
			"",
			"class sortedset(generic[T]):",
			"    bucket_ratio = 50",
			"    rebuild_ratio = 170",
			"",
			"    def _build(self, a=None) -> None:",
			"        'evenly divide `a` into buckets.'",
			"        if a is none: a = list(self)",
			"        size = self.size = len(a)",
			"        bucket_size = int(math.ceil(math.sqrt(size / self.bucket_ratio)))",
			"        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
			"",
			"    def __init__(self, a: iterable[t] = []) -> None:",
			"        'make a new sortedset from iterable. / o(n) if sorted and unique / o(n log n)'",
			"        a = list(a)",
			"        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
			"            a = sorted(set(a))",
			"        self._build(a)",
			"",
			"    def __iter__(self) -> iterator[t]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"",
			"    def __len__(self) -> int:",
			"        return self.size",
			"",
			"    def __repr__(self) -> str:",
			"        return 'SortedSet' + str(self.a)",
			"",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return '{' + s[1 : len(s) - 1] + '}'",
			"",
			"    def _find_bucket(self, x: T) -> List[T]:",
			"        'Find the bucket which should contain x. self must not be empty.'",
			"        for a in self.a:",
			"            if x <= a[-1]: return a",
			"        return a",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a = self._find_bucket(x)",
			"        i = bisect_left(a, x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def add(self, x: T) -> bool:",
			"        'Add an element and return True if added. / O(√N)'",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return True",
			"        a = self._find_bucket(x)",
			"        i = bisect_left(a, x)",
			"        if i != len(a) and a[i] == x: return False",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.REBUILD_RATIO:",
			"            self._build()",
			"        return True",
			"",
			"    def discard(self, x: T) -> bool:",
			"        'Remove an element and return True if removed. / O(√N)'",
			"        if self.size == 0: return False",
			"        a = self._find_bucket(x)",
			"        i = bisect_left(a, x)",
			"        if i == len(a) or a[i] != x: return False",
			"        a.pop(i)",
			"        self.size -= 1",
			"        if len(a) == 0: self._build()",
			"        return True",
			"",
			"    def lt(self, x: T) -> Union[T, None]:",
			'        "Find the largest element < x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Union[T, None]:",
			'        "Find the largest element <= x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Union[T, None]:",
			'        "Find the smallest element > x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Union[T, None]:",
			'        "Find the smallest element >= x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, x: int) -> T:",
			'        "Return the x-th element, or IndexError if it doesn\'t exist."',
			"        if x < 0: x += self.size",
			"        if x < 0: raise IndexError",
			"        for a in self.a:",
			"            if x < len(a): return a[x]",
			"            x -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			"        'Count the number of elements < x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			"        'Count the number of elements <= x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans",
		})
	),
	s(
		{ trig = "SortedMultiSet", dscr = "SortedMultiSet" },
		t({
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
			"import math",
			"from bisect import bisect_left, bisect_right, insort",
			"from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
			"T = TypeVar('T')",
			"",
			"class SortedMultiset(Generic[T]):",
			"    BUCKET_RATIO = 50",
			"    REBUILD_RATIO = 170",
			"",
			"    def _build(self, a=None) -> None:",
			'        "Evenly divide `a` into buckets."',
			"        if a is None: a = list(self)",
			"        size = self.size = len(a)",
			"        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
			"        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
			"    ",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			"        'Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)'",
			"        a = list(a)",
			"        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
			"            a = sorted(a)",
			"        self._build(a)",
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"    ",
			"    def __len__(self) -> int:",
			"        return self.size",
			"    ",
			"    def __repr__(self) -> str:",
			"        return 'SortedMultiset' + str(self.a)",
			"    ",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return '{' + s[1 : len(s) - 1] + '}'",
			"",
			"    def _find_bucket(self, x: T) -> List[T]:",
			"        'Find the bucket which should contain x. self must not be empty.'",
			"        for a in self.a:",
			"            if x <= a[-1]: return a",
			"        return a",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a = self._find_bucket(x)",
			"        i = bisect_left(a, x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def count(self, x: T) -> int:",
			"        'Count the number of x.'",
			"        return self.index_right(x) - self.index(x)",
			"",
			"    def add(self, x: T) -> None:",
			"        'Add an element. / O(√N)'",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return",
			"        a = self._find_bucket(x)",
			"        insort(a, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.REBUILD_RATIO:",
			"            self._build()",
			"",
			"    def discard(self, x: T) -> bool:",
			"        'Remove an element and return True if removed. / O(√N)'",
			"        if self.size == 0: return False",
			"        a = self._find_bucket(x)",
			"        i = bisect_left(a, x)",
			"        if i == len(a) or a[i] != x: return False",
			"        a.pop(i)",
			"        self.size -= 1",
			"        if len(a) == 0: self._build()",
			"        return True",
			"",
			"    def lt(self, x: T) -> Union[T, None]:",
			'        "Find the largest element < x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Union[T, None]:",
			'        "Find the largest element <= x, or None if it doesn\'t exist."',
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Union[T, None]:",
			'        "Find the smallest element > x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Union[T, None]:",
			'        "Find the smallest element >= x, or None if it doesn\'t exist."',
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, x: int) -> T:",
			'        "Return the x-th element, or IndexError if it doesn\'t exist."',
			"        if x < 0: x += self.size",
			"        if x < 0: raise IndexError",
			"        for a in self.a:",
			"            if x < len(a): return a[x]",
			"            x -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			"        'Count the number of elements < x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			"        'Count the number of elements <= x.'",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans",
		})
	),
}
